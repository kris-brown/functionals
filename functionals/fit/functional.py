# External Modules
from typing import Callable, TYPE_CHECKING,Tuple,Optional as O
from abc import ABCMeta, abstractmethod
from json import load
import numpy as np               # type: ignore
from matplotlib.axes import Axes # type: ignore

# Internal
if TYPE_CHECKING:
    from functionals.fit.data import Data

from functionals.fit.utilities import LegendreProduct
################################################################################
# Functional constants
#---------------------
mu_pbe   = 0.2195149727645171
kappa    = 0.804
mu       = 10./81
################################################################################
# Functional classes
#-------------------
class Functional(object,metaclass=ABCMeta):
    """
    A mGGA: something that implements a function (s,⍺)->Fx :: (ℝ+,ℝ+)->ℝ+
    """
    @property
    @abstractmethod
    def name(self)->str: pass

    @property
    @abstractmethod
    def mgga(self)->bool: pass

    @abstractmethod
    def apply(self,s:float,a:float)->float:
        raise NotImplementedError

    def plot(self,ax : Axes,color  : str = 'k') -> None:
        ss     = np.arange(0.,3.5,0.05)
        alphas = np.array([0,1]) if self.mgga else [1]
        styles = ['-',':','--','-.']

        for style,alpha in zip(styles,alphas):
            ys  = [self.apply(s,alpha) for s in ss]
            lab = self.name + r' ($\alpha$=%d)'%alpha if self.mgga else self.name
            ax.plot(ss,ys,color=color,linestyle=style,label=lab,
                    alpha=1 if self.mgga else 0.3)

# Different ways of creating a functional
class FromFunc(Functional):
    """ Directly specify the enhancement factor formula """
    def __init__(self,name:str,f:Callable[[float,float],float],mgga:bool=True)->None:
        self._name=name; self.f = f; self._mgga = mgga

    @property
    def name(self)->str: return self._name

    @property
    def mgga(self)->bool: return self._mgga

    def apply(self,s:float,a:float)->float:
        return self.f(s,a)

class FromMatrix(Functional):
    """
    Implicitly define Fx formula in terms of a 2D matrix corresponding to
    coefficients for Legendre Polynomials
    """
    def __init__(self,A:np.array,name:O[str]=None)->None:
        self.A = A
        self.x = A.flatten()
        self.N,self.M = A.shape
        assert self.N==self.M
        self._name = name or '<no name>'

    @property
    def name(self)->str: return self._name

    @property
    def mgga(self)->bool: return True

    def apply(self,s:float,a:float)->float:
        """
        A - an MxN matrix with rows corresponding to s basis functions coefficients
            and columns corresponding to alpha basis function coefficients

        Eq # 5 in mBEEF paper
        """

        P = np.array([[LegendreProduct(s,a,j,i)
                        for j in range(self.N)]
                        for i in range(self.M)])

        return np.sum(np.multiply(self.A,P))

    def resid(self,d:'Data')->Tuple[float,np.array]:
        res = d.A(len(self.x)) @ self.x - d.target
        return res@res,res

################################################################################
# Functional instances
#---------------------

# Functionals generated by Explicit enhancement factor functions
#----------------------------------------------------------------
PBE    = FromFunc('PBE',   lambda s,_: 1. + kappa*(1. - 1./(1. + mu_pbe*s**2 / kappa)),mgga=False)
RPBE   = FromFunc('RPBE',  lambda s,_: 1. + kappa*(1. - np.exp(-mu_pbe*s**2 / kappa)),mgga=False)
PBEsol = FromFunc('PBEsol',lambda s,_: 1. + kappa*(1. - 1./(1.+mu*s**2 / kappa)),mgga=False)

def fxSCAN(s:float,alpha:float)->float:
    # Scan-specific constants
    h0x,c1x,c2x,dx,b3,k1,a1 = 1.174,0.667,0.8,1.24,0.5,0.065,4.9479
    b2 = (5913/405000)**0.5
    b1 = (511/13500) / (2*b2)
    b4 = mu**2/k1 - 1606/18225 - b1**2
    # Edge conditions with numerical instability
    assert s >= 0 and alpha >= 0
    if s < 0.01: s = 0.01
    if abs(alpha-1) < 0.01: alpha = 1.001
    # Intermediate values
    theta_1a = float(np.heaviside(1-alpha,0.5))
    theta_a1 = float(np.heaviside(alpha-1,0.5))
    s2  = s**2
    x   = mu*s2*(1 + b4*s2/mu) + (b1*s2 + b2*(1-alpha)*np.exp(-b3*(1-alpha)**2))**2
    h1x = 1 + k1 - k1/(1+x/k1)
    gx  = 1 - np.exp(-a1*s**(-0.5))
    fx  = np.exp(-c1x*alpha/(1-alpha))*theta_1a - dx*np.exp(c2x/(1-alpha))*theta_a1
    # Main output
    return (h1x + fx*(h0x-h1x))*gx

SCAN = FromFunc('SCAN',fxSCAN)

def fxMS2(s:float,alpha:float)->float:
    k,c,b = 0.504,0.14601,4.0
    p     = s**2
    F1x   = 1 + k - k/(1+mu*p/k)
    F0x   = 1 + k - k/(1+(mu*p+c)/k)
    f     = (1-alpha**2) / (1 + alpha**3 + b*alpha**6)
    return F1x + f*(F0x-F1x)

MS2 = FromFunc('MS2',fxMS2)

# From data
#----------
with open('/Users/ksb/functionals/data/beef.json') as f:
    beefcoeff = np.array(load(f))

BEEF = FromMatrix(beefcoeff.reshape(8,8),'beef')
